# -*- coding: utf-8 -*-
"""qwen.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17UDpGqlo8XTxvqUYB_y1ai-g_Vd4UqMT
"""

from transformers import AutoModelForCausalLM, AutoTokenizer
device = "cuda" # the device to load the model onto

model = AutoModelForCausalLM.from_pretrained(
    "Qwen/Qwen2-7B-Instruct",
    torch_dtype="auto",
    device_map="auto"
)
tokenizer = AutoTokenizer.from_pretrained("Qwen/Qwen2-7B-Instruct")

import json
class DialogueManager:
    def generate_response(self, user_input):
      prompt = f"""
You are an expert at extracting movie metadata and analyzing sentiment.
Output **only** valid JSON with exactly two top-level keys: "metadata" and "sentiment".

REQUIRED JSON STRUCTURE:
{{"metadata": {{...}}, "sentiment": {{"sentiment": "..."}}}}

VALID GENRES ONLY:
â€¢ Extract ONLY these as genres: action, thriller, horror, comedy, drama, romance, sci-fi, fantasy, adventure, crime, mystery, documentary, animation, musical, western, war, biography, family, psychological, superhero
â€¢ NEVER extract: entertaining, fun, exciting, cheesy, ridiculous, good, great, amazing, awesome, interesting, cool, nice, enjoyable, fantastic, wonderful

STRICT VALIDATION RULES:
â€¢ NEVER extract genres that aren't explicitly mentioned using exact genre words
â€¢ "entertaining" is NOT a genre - it's descriptive content for review
â€¢ "fun" is NOT a genre - it's descriptive content for review
â€¢ "cheesy" is NOT a genre - it's descriptive content for review
â€¢ "ridiculous" is NOT a genre - it's descriptive content for review
â€¢ "enjoyable" is NOT a genre - it's descriptive content for review
â€¢ Only extract if user literally says the exact genre word from valid list

"metadata": one flat dictionary â€”
â€¢ If greeting (hi, hello, good morning, etc.): {{"greet": "<exact words>"}}
â€¢ If explicit movie metadata (genre, director, actor, year): use those keys
â€¢ If no explicit metadata: {{"review": "<direct summary of preferences>"}}
â€¢ Extract ALL mentioned entities, including negative context
â€¢ NEVER include sentiment inside metadata - keep completely separate

"sentiment": one dictionary with single key "sentiment"
â€¢ Key: must be exactly "sentiment"
â€¢ Value: comma-separated sentiment matching metadata entity count
â€¢ For greetings: "neutral"
â€¢ For others: "like", "dislike", "neutral" (lowercase only)

CRITICAL EXTRACTION RULES - NEGATIVE CONTEXT:
â€¢ Extract ALL entities mentioned with "not", "but not", "except", "hate", "dislike"
â€¢ "I like comedy but not action" â†’ extract BOTH: "comedy, action"
â€¢ "I like horror but not romantic" â†’ extract BOTH: "horror, romance"
â€¢ "I want action not comedy" â†’ extract BOTH: "action, comedy"
â€¢ "I love Nolan but hate Tom Cruise" â†’ extract BOTH: "Nolan" and "Tom Cruise"
â€¢ Sentiment reflects the user's feeling toward each entity in order

REVIEW FIELD EXCLUSION RULES:
â€¢ DO NOT create review field if input only contains valid genres/directors/actors with no additional descriptive content
â€¢ "I like action movies" â†’ ONLY extract genre: "action" (NO review needed)
â€¢ "I like comedy and horror" â†’ ONLY extract genre: "comedy, horror" (NO review needed)
â€¢ "I like action movies with great stunts" â†’ extract genre: "action" + review: "Movies with great stunts"
â€¢ Review field should ONLY exist when there are movie characteristics beyond basic metadata

WHEN TO EXCLUDE REVIEW:
â€¢ Input contains only: "I like [genre]", "I want [genre]", "I enjoy [genre]"
â€¢ Input contains only genres, actors, directors with basic preference verbs
â€¢ NO additional descriptive movie characteristics mentioned

WHEN TO INCLUDE REVIEW:
â€¢ Additional characteristics mentioned: "with great stunts", "that are entertaining", "without violence"
â€¢ Production companies mentioned: "Marvel films", "Disney movies"
â€¢ Movie qualities described: "fast-paced", "character-driven", "well-written"
â€¢ Descriptive adjectives: "cheesy", "ridiculous", "fun", "entertaining"

EXTRACTION DECISION LOGIC:
â€¢ Input: "I like comedy and horror movies"
  Output: {{"metadata": {{"genre": "comedy, horror"}}, "sentiment": {{"sentiment": "like, like"}}}}
  Reason: Only explicit genres mentioned, no descriptive content

â€¢ Input: "I like entertaining comedy movies"
  Output: {{"metadata": {{"genre": "comedy", "review": "Entertaining comedy movies"}}, "sentiment": {{"sentiment": "like, like"}}}}
  Reason: Genre + descriptive content ("entertaining")

â€¢ Input: "I want action movies with great car chases"
  Output: {{"metadata": {{"genre": "action", "review": "Movies with great car chases"}}, "sentiment": {{"sentiment": "like, like"}}}}
  Reason: Genre + specific movie characteristic

â€¢ Input: "Something entertaining and fun"
  Output: {{"metadata": {{"review": "Entertaining and fun movies"}}, "sentiment": {{"sentiment": "like"}}}}
  Reason: Only descriptive content, no explicit genres

SIMPLE GENRE-ONLY INPUTS (NO REVIEW):
â€¢ "I like horror"
â€¢ "I want comedy and drama"
â€¢ "I enjoy action movies"
â€¢ "I prefer thriller films"
â€¢ "I like comedy but not action"

SENTIMENT ALIGNMENT RULES:
â€¢ Build the sentiment list so its length equals the TOTAL number of metadata entities

How to count entities:
1. For every metadata key:
   - Keys with comma-separated values (genre, actor, director, year)
     â†’ each comma-separated item = 1 entity
     â†’ e.g. "action, comedy, drama" = 3 entities
   - Keys with a single value (greet, review)
     â†’ always count as 1 entity

2. Sum the entities from all keys to get N

3. Provide exactly N comma-separated sentiment words
   - Order must mirror the order the entities appear

EXAMPLES WITH SENTIMENT COUNTS:
â€¢ {{"metadata": {{"genre": "horror, romance"}}, "sentiment": {{"sentiment": "like, dislike"}}}}
  â†’ 2 entities, 2 sentiments

â€¢ {{"metadata": {{"genre": "superhero, action", "review": "Marvel films with good dialogue"}}, "sentiment": {{"sentiment": "like, like, like"}}}}
  â†’ 2 + 1 = 3 entities, 3 sentiments

â€¢ {{"metadata": {{"actor": "Tom Cruise"}}, "sentiment": {{"sentiment": "like"}}}}
  â†’ 1 entity, 1 sentiment

â€¢ {{"metadata": {{"review": "Entertaining movies"}}, "sentiment": {{"sentiment": "like"}}}}
  â†’ 1 entity, 1 sentiment

CRITICAL FORMAT RULES:
â€¢ NEVER put sentiment inside metadata dictionary
â€¢ NEVER duplicate keys in JSON
â€¢ Always extract entities mentioned with negative words (not, but not, hate, except)
â€¢ Use "romance" not "romantic" as genre
â€¢ Keep metadata and sentiment as separate top-level keys only
â€¢ Sentiment word choice: Use only: like, dislike, neutral (lowercase)

MANDATORY EXAMPLES FOR NEGATIVE CONTEXT:
â€¢ "I like comedy but not action" â†’ {{"metadata": {{"genre": "comedy, action"}}, "sentiment": {{"sentiment": "like, dislike"}}}}
â€¢ "I want Christopher Nolan films but not with Tom Cruise" â†’ {{"metadata": {{"director": "Christopher Nolan", "actor": "Tom Cruise"}}, "sentiment": {{"sentiment": "like, dislike"}}}}
â€¢ "I love action and comedy movies" â†’ {{"metadata": {{"genre": "action, comedy"}}, "sentiment": {{"sentiment": "like, like"}}}}

Remember:
â€¢ Extract ALL entities mentioned, especially those with negative context
â€¢ NEVER put sentiment inside metadata
â€¢ Always extract both liked AND disliked entities
â€¢ Only create review field when descriptive content exists beyond basic genres/actors/directors
â€¢ Sentiment count must EXACTLY match total metadata entity count
â€¢ Use only lowercase like/dislike/neutral
â€¢ NEVER wrap JSON in triple back-ticks
â€¢ Keep metadata and sentiment as completely separate top-level keys
â€¢ Only extract exact genre words from valid list
â€¢ Use review for all descriptive content that isn't a valid genre

User: "{user_input}"
Assistant:
"""
      messages = [
          {"role": "system", "content": "You are a helpful assistant that outputs only valid JSON."},
          {"role": "user", "content": prompt}
      ]

      text = tokenizer.apply_chat_template(
          messages,
          tokenize=False,
          add_generation_prompt=True
      )
      model_inputs = tokenizer([text], return_tensors="pt").to(device)

      generated_ids = model.generate(
          model_inputs.input_ids,
          max_new_tokens=512,
          temperature=0.1,
          do_sample=True
      )
      generated_ids = [
          output_ids[len(input_ids):] for input_ids, output_ids in zip(model_inputs.input_ids, generated_ids)
      ]

      response = tokenizer.batch_decode(generated_ids, skip_special_tokens=True)[0]
      return response

a = DialogueManager()
while True:
    user_input = input("You: ").strip()

    if user_input.lower() in ['quit', 'exit', 'q']:
        print("ðŸ‘‹ Goodbye!")
        break

    response = a.generate_response(user_input)
    raw_json = response.strip()
    data = json.loads(raw_json)
    print(data)

